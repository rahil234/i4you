// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: discovery/v2/discovery.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "discovery.v2";

export interface GetPotentialMatchesRequest {
  showMe: string;
  minAge: number;
  maxAge: number;
  maxDistance: number;
  locationLat: number;
  locationLng: number;
  lookingFor: string;
  excludeUserIds: string[];
}

export interface Location {
  type: string;
  coordinates: number[];
  displayName: string;
}

export interface Match {
  id: string;
  name: string;
  email: string;
  age: number;
  gender: string;
  bio: string;
  photos: string[];
  interests: string[];
  location?: Location | undefined;
  distance: number;
  status: string;
}

export interface GetPotentialMatchesResponse {
  matches: Match[];
}

function createBaseGetPotentialMatchesRequest(): GetPotentialMatchesRequest {
  return {
    showMe: "",
    minAge: 0,
    maxAge: 0,
    maxDistance: 0,
    locationLat: 0,
    locationLng: 0,
    lookingFor: "",
    excludeUserIds: [],
  };
}

export const GetPotentialMatchesRequest: MessageFns<GetPotentialMatchesRequest> = {
  encode(message: GetPotentialMatchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.showMe !== "") {
      writer.uint32(18).string(message.showMe);
    }
    if (message.minAge !== 0) {
      writer.uint32(24).int32(message.minAge);
    }
    if (message.maxAge !== 0) {
      writer.uint32(32).int32(message.maxAge);
    }
    if (message.maxDistance !== 0) {
      writer.uint32(40).int32(message.maxDistance);
    }
    if (message.locationLat !== 0) {
      writer.uint32(49).double(message.locationLat);
    }
    if (message.locationLng !== 0) {
      writer.uint32(57).double(message.locationLng);
    }
    if (message.lookingFor !== "") {
      writer.uint32(66).string(message.lookingFor);
    }
    for (const v of message.excludeUserIds) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPotentialMatchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPotentialMatchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.showMe = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minAge = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxAge = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxDistance = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.locationLat = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.locationLng = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lookingFor = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.excludeUserIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPotentialMatchesRequest {
    return {
      showMe: isSet(object.showMe) ? globalThis.String(object.showMe) : "",
      minAge: isSet(object.minAge) ? globalThis.Number(object.minAge) : 0,
      maxAge: isSet(object.maxAge) ? globalThis.Number(object.maxAge) : 0,
      maxDistance: isSet(object.maxDistance) ? globalThis.Number(object.maxDistance) : 0,
      locationLat: isSet(object.locationLat) ? globalThis.Number(object.locationLat) : 0,
      locationLng: isSet(object.locationLng) ? globalThis.Number(object.locationLng) : 0,
      lookingFor: isSet(object.lookingFor) ? globalThis.String(object.lookingFor) : "",
      excludeUserIds: globalThis.Array.isArray(object?.excludeUserIds)
        ? object.excludeUserIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetPotentialMatchesRequest): unknown {
    const obj: any = {};
    if (message.showMe !== "") {
      obj.showMe = message.showMe;
    }
    if (message.minAge !== 0) {
      obj.minAge = Math.round(message.minAge);
    }
    if (message.maxAge !== 0) {
      obj.maxAge = Math.round(message.maxAge);
    }
    if (message.maxDistance !== 0) {
      obj.maxDistance = Math.round(message.maxDistance);
    }
    if (message.locationLat !== 0) {
      obj.locationLat = message.locationLat;
    }
    if (message.locationLng !== 0) {
      obj.locationLng = message.locationLng;
    }
    if (message.lookingFor !== "") {
      obj.lookingFor = message.lookingFor;
    }
    if (message.excludeUserIds?.length) {
      obj.excludeUserIds = message.excludeUserIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPotentialMatchesRequest>, I>>(base?: I): GetPotentialMatchesRequest {
    return GetPotentialMatchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPotentialMatchesRequest>, I>>(object: I): GetPotentialMatchesRequest {
    const message = createBaseGetPotentialMatchesRequest();
    message.showMe = object.showMe ?? "";
    message.minAge = object.minAge ?? 0;
    message.maxAge = object.maxAge ?? 0;
    message.maxDistance = object.maxDistance ?? 0;
    message.locationLat = object.locationLat ?? 0;
    message.locationLng = object.locationLng ?? 0;
    message.lookingFor = object.lookingFor ?? "";
    message.excludeUserIds = object.excludeUserIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseLocation(): Location {
  return { type: "", coordinates: [], displayName: "" };
}

export const Location: MessageFns<Location> = {
  encode(message: Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    writer.uint32(18).fork();
    for (const v of message.coordinates) {
      writer.double(v);
    }
    writer.join();
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag === 17) {
            message.coordinates.push(reader.double());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.coordinates.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Location {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      coordinates: globalThis.Array.isArray(object?.coordinates)
        ? object.coordinates.map((e: any) => globalThis.Number(e))
        : [],
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: Location): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.coordinates?.length) {
      obj.coordinates = message.coordinates;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Location>, I>>(base?: I): Location {
    return Location.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Location>, I>>(object: I): Location {
    const message = createBaseLocation();
    message.type = object.type ?? "";
    message.coordinates = object.coordinates?.map((e) => e) || [];
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseMatch(): Match {
  return {
    id: "",
    name: "",
    email: "",
    age: 0,
    gender: "",
    bio: "",
    photos: [],
    interests: [],
    location: undefined,
    distance: 0,
    status: "",
  };
}

export const Match: MessageFns<Match> = {
  encode(message: Match, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.age !== 0) {
      writer.uint32(32).int32(message.age);
    }
    if (message.gender !== "") {
      writer.uint32(42).string(message.gender);
    }
    if (message.bio !== "") {
      writer.uint32(50).string(message.bio);
    }
    for (const v of message.photos) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.interests) {
      writer.uint32(66).string(v!);
    }
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(74).fork()).join();
    }
    if (message.distance !== 0) {
      writer.uint32(81).double(message.distance);
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Match {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.age = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bio = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.photos.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.interests.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.distance = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Match {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      age: isSet(object.age) ? globalThis.Number(object.age) : 0,
      gender: isSet(object.gender) ? globalThis.String(object.gender) : "",
      bio: isSet(object.bio) ? globalThis.String(object.bio) : "",
      photos: globalThis.Array.isArray(object?.photos) ? object.photos.map((e: any) => globalThis.String(e)) : [],
      interests: globalThis.Array.isArray(object?.interests)
        ? object.interests.map((e: any) => globalThis.String(e))
        : [],
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: Match): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.age !== 0) {
      obj.age = Math.round(message.age);
    }
    if (message.gender !== "") {
      obj.gender = message.gender;
    }
    if (message.bio !== "") {
      obj.bio = message.bio;
    }
    if (message.photos?.length) {
      obj.photos = message.photos;
    }
    if (message.interests?.length) {
      obj.interests = message.interests;
    }
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    if (message.distance !== 0) {
      obj.distance = message.distance;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Match>, I>>(base?: I): Match {
    return Match.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Match>, I>>(object: I): Match {
    const message = createBaseMatch();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.age = object.age ?? 0;
    message.gender = object.gender ?? "";
    message.bio = object.bio ?? "";
    message.photos = object.photos?.map((e) => e) || [];
    message.interests = object.interests?.map((e) => e) || [];
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    message.distance = object.distance ?? 0;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseGetPotentialMatchesResponse(): GetPotentialMatchesResponse {
  return { matches: [] };
}

export const GetPotentialMatchesResponse: MessageFns<GetPotentialMatchesResponse> = {
  encode(message: GetPotentialMatchesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      Match.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPotentialMatchesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPotentialMatchesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(Match.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPotentialMatchesResponse {
    return {
      matches: globalThis.Array.isArray(object?.matches) ? object.matches.map((e: any) => Match.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetPotentialMatchesResponse): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => Match.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPotentialMatchesResponse>, I>>(base?: I): GetPotentialMatchesResponse {
    return GetPotentialMatchesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPotentialMatchesResponse>, I>>(object: I): GetPotentialMatchesResponse {
    const message = createBaseGetPotentialMatchesResponse();
    message.matches = object.matches?.map((e) => Match.fromPartial(e)) || [];
    return message;
  },
};

export type DiscoverServiceService = typeof DiscoverServiceService;
export const DiscoverServiceService = {
  getPotentialMatches: {
    path: "/discovery.v2.DiscoverService/GetPotentialMatches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPotentialMatchesRequest): Buffer =>
      Buffer.from(GetPotentialMatchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPotentialMatchesRequest => GetPotentialMatchesRequest.decode(value),
    responseSerialize: (value: GetPotentialMatchesResponse): Buffer =>
      Buffer.from(GetPotentialMatchesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetPotentialMatchesResponse => GetPotentialMatchesResponse.decode(value),
  },
} as const;

export interface DiscoverServiceServer extends UntypedServiceImplementation {
  getPotentialMatches: handleUnaryCall<GetPotentialMatchesRequest, GetPotentialMatchesResponse>;
}

export interface DiscoverServiceClient extends Client {
  getPotentialMatches(
    request: GetPotentialMatchesRequest,
    callback: (error: ServiceError | null, response: GetPotentialMatchesResponse) => void,
  ): ClientUnaryCall;
  getPotentialMatches(
    request: GetPotentialMatchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPotentialMatchesResponse) => void,
  ): ClientUnaryCall;
  getPotentialMatches(
    request: GetPotentialMatchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPotentialMatchesResponse) => void,
  ): ClientUnaryCall;
}

export const DiscoverServiceClient = makeGenericClientConstructor(
  DiscoverServiceService,
  "discovery.v2.DiscoverService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DiscoverServiceClient;
  service: typeof DiscoverServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
